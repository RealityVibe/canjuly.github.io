---
layout:     post                    # 使用的布局（不需要改）
title:      乱七八糟的二分搜索        # 标题 
subtitle:   千万别信                 #副标题
date:       2018-06-12              # 时间
author:     canjuly                 # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 生活
---
## 写在前面
> 我为啥要写这玩意？

刚写期末作业，从电脑里翻出一个叫二分搜索的文档，仔细看看发现是一年之前为了骗点津贴写的讲稿，后来似乎津贴也没了，遂不了了之。看了写了蛮多的，不舍得扔，索性放上来算了。

当然这篇讲稿写的思绪混乱，估计还有一些错误，不要太当真。

# 二分搜索——让你的搜索快人一步

众所周知，搜索是计算机非常重要的应用，如何从浩如烟海的数据中找到我们所要的那个数据并不是一件那么容易的事情，尤其是在我们现如今这个信息爆炸的时代。人工自然无法应对，所以如何使用计算机来快速地完成这件事，就显得非常重要了。

首先我们来想一下我们最普通的搜索算法：如何在一列无序的，元素各不相同的数中最快的查找到我们所想要找的那个数呢？显然的，因为这列数是无序的，他可能出现在数组中的任意位置，并且这个位置没有任何特征。所以我们除了遍历一遍整个数组之外别无选择。显然这样最坏的情况是要遍历整个数组，所以时间复杂度达到了O(n)。假如这个数组有一亿个元素的话，那么计算机按这种算法去处理的话，显然效率就是并不那么使人满意。

那么我们假如换一下条件，让我们原来的这个数组从无序改成升序（或者降序）呢？这个时候我们有没有更加快一点的方法去实现搜索呢？比如下面这个例子：

>例1：
>现在有一个长度n=5的升序数组a{2,3,6,8,9}，我们要找到一个数k=8的位置。

假设现在我是一无所知的萌新，我自然会从头开始遍历，先遍历到2，发现不是我们要找的数，于是我们又遍历到3，发现也不是我们要找的数，于是继续遍历到6，还不是我们要找的数，继续遍历到8，发现就是我们需要的，于是结束，返回答案4，即8在数组中的位置是第四个。

很多人会想，这也太麻烦了，有序的数列还要这么找，那它的有序又有什么用呢？于是萌新的我决定试一试跳着找：我从头开始遍历，先遍历到2，发现不是我们要找的数，于是我决定跳一下，遍历后面第二个元素也就是6，还不是我们要找的数，继续跳一个遍历到9，发现比8大了，因为数组是升序的，所以我就往前找，然后就找到了8，于是返回答案4。这样就用到了升序这个条件，显然如果数组更大，那么我们现在这种做法就会比原来的方法快一倍。

跳一个既然可以，那我们为什么不跳两个，不跳三个呢？于是我们试了一下，发现都可以，而且效率也都提升了。但是这样跳着找又太不稳定了，我怎么知道到底跳几个才能让效率不那么慢？这时，我们的二分搜索就闪亮登场了。

其实上面的那个方法已经有了一点二分的思想在里面，但是显得比较僵硬。二分搜索并不从头开始搜索，跳的步数也不是固定的。二分搜索先是将数组的中位数与关键字比较，如果二者相等，那么查找成功，那么查找成功，返回结果。否则根据中间位置将表分成前后两个新数组，如果中位数大于关键字，就进一步搜索前一子数组，如果中位数小于关键字就进一步查找后一子数组。重复这个操作，直到找到关键字为止。
对于例1来说，我们就先拿8和数组的中位数6去比，发现8比6要大，于是我们就查找6后面的位置，即{8,9},这个数组的中位数是8，与关键字相同，于是我们返回8在原数组中的位置4。代码可以写出如下所示：

`#include<iostream>
using namespace std;
int a[100];
int search(int left, int right, int key)
{
	int middle = (left + right) / 2;
	if (a[middle] == key)
		return middle;
	else if (a[middle] < key)
		return search(middle + 1, right, key);
	else
		return search(left, middle - 1, key);
}
int main()
{
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	int k;
	cin >> k;
	cout << search(1, n, k) << endl;
	return 0;
}`

显然的，因为每次比较我们都将数据规模缩小了一半，所以二分查找的时间复杂度位O(log2(n))。这样就会使得效率非常的高。但是二分查找的缺点也是显而易见的：它无法适用无序的数组。
那么难道无序的数组还是用朴素的逐个比较吗？其实这也是看情况的。假如只有一次询问，那么逐个比较的时间复杂度是O(n)，而二分搜索需要先将数组排序再搜，所以时间复杂度位O(n*log2(n)+log2(n))，毫无疑问逐个比较是更优的方法，但是我们实际情况中，往往要处理不止一次询问，现在假设我们又q次询问，那么逐个比较的时间复杂度就变成了O(q*n)，而二分搜索的复杂度位O(n*log2(n)+q*log2(n))，因为log2(n)的增长是十分缓慢的，所以这时二分搜索的时间复杂度就比逐个比较优秀太多了。
来个例题吧：
